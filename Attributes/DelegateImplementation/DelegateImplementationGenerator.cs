using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DelegateImplementation;

[Generator]
public sealed class DelegateImplementationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(context.SyntaxProvider
                .CreateSyntaxProvider((node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                    (syntaxContext, _) => (ClassDeclarationSyntax)syntaxContext.Node).Collect()),
            (spc, source) => Execute(spc, source.Left, source.Right)
        );
    }

    private static void Execute(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes
    )
    {
        var attrSymbol = compilation.GetTypeByMetadataName("Attributes.DelegateImplementationAttribute");
        if (attrSymbol == null) return;
        foreach (var classDeclaration in classes)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            if (model.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol) continue;
            foreach (var attributeData in classSymbol.GetAttributes()
                         .Where(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attrSymbol)))
            {
                var interfaceSymbol = (INamedTypeSymbol)attributeData.ConstructorArguments[0].Value;
                var targetProperty = (string)attributeData.ConstructorArguments[1].Value;
                var implicitDelegation = (int)(attributeData.ConstructorArguments[2].Value ?? 0) == 0;
                GenerateDelegation(context, classSymbol, interfaceSymbol, targetProperty, implicitDelegation);
            }
        }
    }

    private static void GenerateDelegation(SourceProductionContext context,
        INamedTypeSymbol classSymbol,
        INamedTypeSymbol interfaceSymbol,
        string targetPropertyName, bool implicitDelegation)
    {
        var ns = classSymbol.ContainingNamespace;
        var className = classSymbol.Name;
        var interfaceName = interfaceSymbol.Name;
        var (methodSymbols, propertySymbols) = ExtractInterfaceSymbols();

        context.AddSource(
            $"{className}_{interfaceSymbol.Name}_Delegation.g.cs",
            SourceText.From(GenSource(), Encoding.UTF8)
        );

        return;

        string GenSource()
        {
            return
                $"// <auto-generated />\n" +
                $"#nullable enable\n" +
                $"{GenUsings()}\n\n" +
                ns.IsGlobalNamespace switch
                {
                    true => GenClassDef(),
                    false => $"namespace {ns.ToDisplayString()}\n{{\n{GenClassDef()}\n}}",
                };
        }

        string GenUsings()
        {
            var namespaces = new HashSet<INamespaceSymbol>(SymbolEqualityComparer.Default);
            foreach (var methodSymbol in methodSymbols)
            {
                CollectNamespaces(methodSymbol.ReturnType, namespaces);
            }

            foreach (var propertySymbol in propertySymbols)
            {
                CollectNamespaces(propertySymbol.Type, namespaces);
            }

            return string.Join("\n", namespaces.Select(n => $"using {n.ToDisplayString()};"));

            void CollectNamespaces(ITypeSymbol type, HashSet<INamespaceSymbol> set)
            {
                while (true)
                {
                    if (type is null) return;
                    if (type.SpecialType == SpecialType.System_Void) return;
                    if (!type.ContainingNamespace.IsGlobalNamespace) set.Add(type.ContainingNamespace);
                    switch (type)
                    {
                        case INamedTypeSymbol named:
                            foreach (var arg in named.TypeArguments) CollectNamespaces(arg, set);
                            break;
                        case IArrayTypeSymbol array:
                            type = array.ElementType;
                            continue;
                        case IPointerTypeSymbol pointer:
                            type = pointer.PointedAtType;
                            continue;
                    }

                    break;
                }
            }
        }

        string GenClassDef()
        {
            return $"public partial class {className} : {interfaceName} {{ {GenClassContent()} }}";
        }

        string GenClassContent()
        {
            var sb = new StringBuilder();
            foreach (var methodSymbol in methodSymbols) sb.AppendLine(GenMethodDelegation(methodSymbol));
            foreach (var propertySymbol in propertySymbols) sb.AppendLine(GenPropertyDelegation(propertySymbol));
            return sb.ToString();
        }

        string GenMethodDelegation(IMethodSymbol method)
        {
            var name = method.Name;
            var returnType = method.ReturnType.ToDisplayString();
            var parameters = string.Join(", ",
                method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
            var args = string.Join(", ", method.Parameters.Select(p => p.Name));
            return $"{GenMemberSignatureName(returnType)}{name}({parameters}) => {targetPropertyName}.{name}({args});";
        }

        string GenPropertyDelegation(IPropertySymbol property)
        {
            var propertyName = property.Name;

            var sb = new StringBuilder();
            sb.AppendLine($"{GenMemberSignatureName(property.Type.ToDisplayString())}{propertyName} {{ {Body()} }}");

            return sb.ToString();

            string Body() =>
                (property.SetMethod != null ? $"set => {targetPropertyName}.{propertyName} = value;" : "") +
                (property.GetMethod != null ? $"get => {targetPropertyName}.{propertyName};" : "");
        }

        string GenMemberSignatureName(string type)
        {
            return implicitDelegation ? $"public {type} " : $"{type} {targetPropertyName}.";
        }

        (List<IMethodSymbol>, List<IPropertySymbol>) ExtractInterfaceSymbols()
        {
            List<IMethodSymbol> methods = [];
            List<IPropertySymbol> properties = [];
            foreach (var interfaceMember in interfaceSymbol.GetMembers())
            {
                switch (interfaceMember)
                {
                    case IMethodSymbol methodSymbol:
                        if (methodSymbol.MethodKind != MethodKind.Ordinary) continue;
                        if (methodSymbol.IsStatic) continue;
                        methods.Add(methodSymbol);
                        break;
                    case IPropertySymbol propertySymbol:
                        properties.Add(propertySymbol);
                        break;
                }
            }

            return (methods, properties);
        }
    }
}
